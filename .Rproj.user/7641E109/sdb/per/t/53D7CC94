{
    "collab_server" : "",
    "contents" : "#include \"util.h\"\n#include<iostream>\n#include<string>\n#include<fstream>\n#include<cstdlib>\n#include<vector>\n#include<map>\n#include<algorithm> \n#include<cmath>\n#include<sstream>\n#include<Rcpp.h>\n#include<omp.h>\n\n// [[Rcpp::plugins(openmp)]]\n\nusing namespace std;\n\n// [[Rcpp::export]]\n\nRcpp::NumericVector bcacpp(Rcpp::NumericMatrix exp, Rcpp::IntegerVector tfs, Rcpp::NumericVector par ){\n    int min_gene = int(par(0)); //mininum number of genes, e.g. 50\n    int max_gene = int(par(1)); //mininum number of genes, e.g. 50\n    int min_patient = int(par(2)); //mininum number of patients, e.g. 50\n\tint step = int(par(3)); //mininum number of patients, e.g. 50\n    float cutoff = float(par(4)); // the core number for multiple threads\n    int cpu = int(par(5)); // the cpu number for multiple threads\n    \n  \t//cout<<par(0)<<\" \"<<par(2)<<\" \"<<par(3) <<endl;\n  \tvector <float> results;\n\tint num_gene = exp.nrow();\n\tint num_patient = exp.ncol();\n\t\n\tRcpp::CharacterVector gene_names = rownames(exp);\n\tRcpp::CharacterVector patient_names = colnames(exp);\n\t//Rcpp::IntegerVector tfs = match(tfs_names, gene_names); \n\tint num_tf= tfs.length();\n\tfloat **input= new float*[num_gene]; // record the expression data\n    for(int i=0;i< num_gene;i++)\n        input[i]= new float[num_patient];\n    for(int i=0;i< num_gene;i++)\n        for(int j=0;j< num_patient;j++)\n        \tinput[i][j]=exp(i,j);\n\t\n\t\n\tconst int nProcessors=cpu; // set the core number\n    omp_set_num_threads(nProcessors);\n\n#pragma omp parallel for\n\t//for(int xxx=0; xxx< 1; xxx++){\n\tfor(int xxx=0; xxx< num_tf; xxx++){\n\t\tfloat cor[num_gene]; // record the expression data\n    \tint wh=int(tfs(xxx))-1; //used as core\n    \t//cout<<patient_names(wh)<<endl;\n    \tint row[num_gene];\n\t\tint col[num_patient];\n\t\tinit(col, num_patient, 1);\n\t\tint left_row = 0;\n\t\tint left_col = num_patient;\n\t\t\n\t\tvector <int> pas;\n\t\tvector <int> nges;\n\t\tvector <float> ar;\n\t\tint mrow=0;\n\t\twhile(left_col >= min_patient){\n\t\t\tcormatrix(input, cor, wh, num_gene, num_patient, col, left_col);\n\t\t\tint has_row=0;\n\t\t\tinit(row, num_gene, 0);\n\t\t\tfor(int i=0; i < num_gene; i++)\n\t\t\t\tif(cor[i] >= cutoff){\n\t\t\t\t\thas_row++;\n\t\t\t\t\trow[i]=1;\n\t\t\t\t}\n\t\t\t//cout<<left_col<<\" \"<<has_row<<endl;\n\t\t\tif(has_row >= max_gene || has_row <  mrow-5 )\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tmrow=has_row;\n\t\t\tint ord[num_gene];\n\t\t\tfor(int i=0;i<num_gene;i++)\n\t\t\t\tord[i]=i;\n\t\t\tmyorder(cor,ord,0, num_gene - 1);\n\t\t\t\n\t\t\tint used[num_gene];\n\t\t\tinit(used, num_gene, 0);\n\t\t\tfor(int j=0;j < min_gene;j++)\n\t\t\t\tused[ord[j]]=1;\n\t\t\t\n\t\t\tused[wh]=0;\n\t\t\tint removal[num_patient]; // to record wich patient to be removed\n\t\t\tinit(removal, num_patient,-1);\n\t\t\tremovepatient(input,removal, used,col, wh, num_patient, num_gene, min_patient, min_gene-1, cutoff); // rank the removed patients\n\t\t\t\n\t\t\tint tag=1;\n\t\t\tfor(int ee=1; ee <= step; ee++){ // remove at most \"step\" patients\n\t\t\t\tinit(row, num_gene, 0);\n\t\t\t\tif(left_col -1 < min_patient){ // reach the min_patients\n\t\t\t\t\ttag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j < num_patient; j++){ // remove one patients\n\t\t\t\t\tif(col[removal[j]]==0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcol[removal[j]]=0;\n\t\t\t\t\tleft_col--;\n\t\t\t\t\tpas.push_back(removal[j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint tst=0;\n\t\t\t\thas_row=0;\n\t\t\t\tvector <float> rs;\n\t\t\t\tfor(int j=0; j < num_gene; j++){ // check if statisfy min_genes\n\t\t\t\t\tfloat rr=newspearman(input, wh, ord[j], col, num_patient, left_col);\n\t\t\t\t\tif(rr > cutoff){\n\t\t\t\t\t\thas_row++;\n\t\t\t\t\t\trow[ord[j]]=1;\n\t\t\t\t\t\trs.push_back(rr);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ttst++;\n\t\t\t\t\t}\n\t\t\t\t\tif(tst > 20){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rs.size()==0)\n\t\t\t\t\tar.push_back(0);\n\t\t\t\telse\n\t\t\t\t\tar.push_back(average(rs));\n\t\t\t\tnges.push_back(has_row);\n\t\t\t\tif(has_row >= max_gene){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tag==0)\n\t\t\t\tbreak;\n\t\t}\n\t\t#pragma omp critical(datainfo)\n{\n\t\tresults.push_back(wh+1);\n\t\tresults.push_back(pas.size());\t\t\n\t\tfor(int i=0;i<pas.size();i++)\n\t\t\tresults.push_back(pas[i]+1);\n\t\tfor(int i=0;i<nges.size();i++)\n\t\t\tresults.push_back(nges[i]);\n\t\tfor(int i=0;i<nges.size();i++)\n\t\t\tresults.push_back(ar[i]);\n}\n\t}\n\tfor(int i=0;i< num_gene;i++)\n        delete input[i];\n    delete input;\n\tint nn=results.size();\n\tRcpp::NumericVector zz(nn);\n\tfor(int i=0; i < nn; i++)\n\t\tzz(i)=results[i];\n    return zz;\n    //return results;\n}\n\n\n\n",
    "created" : 1504773591063.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1871804217",
    "id" : "53D7CC94",
    "lastKnownWriteTime" : 1504764906,
    "last_content_update" : 1504764906,
    "path" : "~/Desktop/bireg/src/bcacpp.cpp",
    "project_path" : "src/bcacpp.cpp",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}