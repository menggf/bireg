{
    "collab_server" : "",
    "contents" : "#include<cmath>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<fstream>\n#include<sstream>\n#include<cstdlib>\n\nusing namespace std;\n\ntemplate <class T>\nint max_pos(T *x, int n){\n\tint i=0;\n\tint wh=0;\n\tfor(i=1;i<n;i++)\n\t\tif(x[i]>x[wh])\n\t\t\twh=i;\n\treturn wh;\n}\ntemplate <class T>\nint min_pos(T *x, int n){\n\tint i=0;\n\tint wh=0;\n\tfor(i=1;i<n;i++)\n\t\tif(x[i] < x[wh])\n\t\t\twh=i;\n\treturn wh;\n}\n\nstring to_string (int a)\n{\n    ostringstream temp;\n    temp<<a;\n    return temp.str();\n}\nvector <string> split(string s, const string delim) {\n    vector<string> result;\n    size_t pos=0;\n    \n    while(1){\n        size_t temp=s.find(delim, pos);\n        if(temp==string::npos){\n            result.push_back(s.substr(pos,1000));\n            return result;\n        }\n        if(temp==pos)\n            result.push_back(\"\");\n        else\n            result.push_back(s.substr(pos,temp-pos));\n        pos=temp+1;\n    }\n    return result;\n}\n\ntemplate <class T>\nvoid init(T *x,int n,T v){\n    for(int i=0;i< n;i++)\n        x[i]=v;\n}\nvoid merge(float *a, int *rank, int r,int m,int l)\n{\n\tint i,j,k;\n\tint n1=m-r+1,n2=l-m;\n\tint *b=new int[n1];\n\tint *c=new int[n2];\n\tfor (i = 0; i<n1; i++) {\n\t\tb[i]=rank[i+r];\n\t}\n\tfor (i = 0; i<n2; i++) {\n\t\tc[i]=rank[i+m+1];\n\t}\n\ti=j=0;\n\tk=r;\n\twhile (i<n1&&j<n2)\n\t{\n\t\tif(a[b[i]] < a[c[j]]){\n\t\t\trank[k]=c[j];\n\t\t\tj++;\n\t\t}\n\t\telse{\n\t\t\trank[k]=b[i];\n\t\t\ti++;\n\t\t}\n\t\tk++;\n\t}\n\twhile (i<n1){\n\t\trank[k]=b[i];\n\t\ti++;\n\t\tk++;\n\t}\n\twhile (j<n2){\n\t\trank[k]=c[j];\n\t\tk++;\n\t\tj++;\n\t}\n\tdelete b;\n\tdelete c;\n}\nvoid merge(int *a, int *rank, int r,int m,int l)\n{\n\tint i,j,k;\n\tint n1=m-r+1,n2=l-m;\n\tint *b=new int[n1];\n\tint *c=new int[n2];\n\tfor (i = 0; i<n1; i++) {\n\t\tb[i]=rank[i+r];\n\t}\n\tfor (i = 0; i<n2; i++) {\n\t\tc[i]=rank[i+m+1];\n\t}\n\ti=j=0;\n\tk=r;\n\twhile (i<n1&&j<n2)\n\t{\n\t\tif(a[b[i]] < a[c[j]]){\n\t\t\trank[k]=c[j];\n\t\t\tj++;\n\t\t}\n\t\telse{\n\t\t\trank[k]=b[i];\n\t\t\ti++;\n\t\t}\n\t\tk++;\n\t}\n\twhile (i<n1){\n\t\trank[k]=b[i];\n\t\ti++;\n\t\tk++;\n\t}\n\twhile (j<n2){\n\t\trank[k]=c[j];\n\t\tk++;\n\t\tj++;\n\t}\n\tdelete b;\n\tdelete c;\n}\ntemplate <class T>\nvoid myorder(T *a,int *rank, int r,int l)\n{\n\tif (r<l) {\n\t\tint m=(r+l)/2;\n\t\tmyorder(a,rank, r,m);\n\t\tmyorder(a,rank, m+1,l);\n\t\tmerge(a,rank, r,m, l);\n\t}\n}\n\ntemplate <class T>\nvoid myorder2(T *cc, int *od,int n){ // get the rank\n\tint *temp=new int[n];\n\tint i;\n\tfor(i=0;i<n;i++)\n\t\ttemp[i]=i;\n    myorder(cc, temp, 0, n-1);\n    for(i=0;i<n;i++)\n    \tod[temp[i]]=i;\n    delete temp;\n}\nfloat pick(float *x,int n,int wh){\n    int temp[n],i;\n    for(i=0;i<n;i++)\n        temp[i]=i;\n    myorder(x,temp,0, n-1);\n    return x[temp[wh-1]];    \n}\nfloat spearman(float **input, int from, int to, int num){ // spearman's correlation\n\tint order1[num], order2[num],i;\n\tfor(i=0;i<num;i++){\n\t\torder1[i]=i;\n\t\torder2[i]=i;\n\t}\n\tmyorder2(input[from], order1, num);\n\tmyorder2(input[to], order2, num);\n\tfloat d=0.0;\n\tfor(int i=0;i<num;i++)\n\t\td =d + pow(order1[i]-order2[i],2);\n\t\n\treturn(1 - 6 * d/(num*(pow(num,2)-1)));\n}\nfloat newspearman(float **input, int from, int to, int *col, int num_patient, int num){ // spearman's correlation by allow exclude some patients\n\tint i,tt=0;\n\tfloat *x=new float[num];\n\tfloat *y=new float[num];\n\tfor(i=0;i<num_patient;i++){\n\t\tif(col[i]==0)\n\t\t\tcontinue;\n\t\tx[tt]=input[from][i];\n\t\ty[tt]=input[to][i];\n\t\ttt++;\n\t}\n\tif(tt!=num){\n\t\tstd::cout<<\"error!\\n\";\n\t\tstd::cout<<tt<<\"\\t\"<<num<<\"\\n\";\n\t}\n\tint order1[num], order2[num];\n\tfor(i=0; i<num; i++){\n\t\torder1[i]=i;\n\t\torder2[i]=i;\n\t}\n\tmyorder2(x, order1, num);\n\tmyorder2(y, order2, num);\n\tdelete x;\n\tdelete y;\n\tfloat d=0.0;\n\tfor(int i=0;i<num;i++)\n\t\td=d + pow(order1[i]-order2[i],2);\n\treturn(1- 6*d/(num*(pow(num,2)-1)));\n}\n\nint myremoval(int target,int partner,int ncol, float **array, int min_patient,float cutoff,int *result, int info=0){ \n    int order1[ncol], order2[ncol],order3[ncol],i=0;\n    for(i=0;i<ncol;i++){\n\t\torder1[i]=i;\n\t\torder2[i]=i;\n\t\torder3[i]=i;\n\t}\n    myorder2(array[target], order1, ncol); // get the rank\n    myorder2(array[partner], order2, ncol); // get the rank\n    //for(int i=0;i<10;i++)\n    //\tcout<<\"\\t\"<<i<<\"\\t\"<<order1[i]<<\"\\t\"<<array[target][i]<<endl;\n    \n    float d[ncol];\n    for(i=0;i<ncol;i++)\n    \td[i]=pow(order1[i]-order2[i],2);\n    myorder(d, order3, 0, ncol-1); // order the rank difference\n    \n    int remove=0;\n    for(i=0;i<ncol;i++){\n    \tfloat r=newspearman(array, target,partner,result, ncol, ncol-remove);\n    \t//cout<<i<<\"\\t\"<<r<<\"\\t\"<< d[order3[i]]<<\"\\t\"<<order3[i]<<endl;\n    \tif(r > cutoff)\n    \t\tbreak;\n    \tresult[order3[i]]=0;\n    \tremove++;\n    \tif(ncol-remove < min_patient)\n    \t\treturn 0;\n    }\n    for(i=0;i<ncol;i++){\n    \tif(i >= remove)\n    \t \tresult[i]=-1; // not remove\n    \t else\n    \t \tresult[i]=order3[i]; // here small number should be remove\n    }\n    return ncol-remove;\n}\n\nvoid vote(short **cc,int *order,int ncol,int n,int window=50){ //use steps to find the, here \"n\" is the gene numbers\n    int i,j,k;\n    int has[ncol]; // make sure not to count the used ones;\n    init(has,ncol,0);\n    int ss[ncol]; //count the occurrence\n    int rr=0;\n    int temp[ncol];\n    for(i=window;i < ncol;i=i+window){\n        init(ss, ncol, 0);\n        for(j=0;j<i;j++){\n            for(k=0;k< n;k++){\n                if(cc[k][j] == -1) // make sure not -1\n                    continue;\n                ss[cc[k][j]]++; // count the rank occurence in the windows\n            }\n        }\n        for(j=0;j<ncol;j++)\n            temp[j]=j;\n        myorder(ss,temp,0,ncol-1);\n        int tt=0;\n        for(j=0;j<ncol;j++){\n            if(has[temp[j]]==1)\n                continue;\n            if(ss[temp[j]]<=((float(n)/10) > 2 ? (float(n)/10):2  ))\n                break;\n            order[rr]=temp[j];\n            has[temp[j]]=1;\n            tt++;\n            rr++;\n            if(rr==ncol-1)\n                break;\n            if(tt==window)\n                break;\n        }\n    }\n    for(i=0;i<ncol;i++){\n        if(has[temp[i]]==1)\n            continue;\n        order[rr]=temp[i];\n        rr++;\n        if(rr==ncol)\n            break;\n    }\n}\n\nint connectivity(short **mx, int *remove, int num, float cutoff, int min_gene){\n\tinit(remove,num,0);\n\tint have=num;\n\tint sum[num];\n\tfor(int i=0;i<num; i++){\n\t\tsum[i]=0;\n\t\tfor(int j=0;j<num;j++)\n\t\t\tsum[i]+=mx[i][j];\n\t}\n\twhile(have >= min_gene){\n\t\tint wh=min_pos(sum, num);\n\t\tif(sum[wh] >= have*cutoff)\n\t\t\treturn have;\n\t\tremove[wh]=1;\n\t\thave--;\n\t\tfor(int i=0;i<num;i++)\n\t\t\tif(remove[i]==1)\n\t\t\t\tsum[i]=num;\n\t\t\telse\n\t\t\t\tsum[i]-=mx[wh][i];\n\t}\n\treturn -1;\n}\nvoid iscore(float **sim, float *row, int num_gene, int min_gene,  vector <int> &c1, float mycutoff){\n\tfor(int i=0;i < num_gene;i++){\n    \tif(row[i] > 0.0 ) // not to count the used ones\n      \t\tcontinue;\n      \tint ccc1=0; //counts \n       \tfor(int j=0;j< num_gene;j++){\n       \t\tif(sim[i][j] < mycutoff || row[j]> 0.0)\n       \t\t\tcontinue;\n           \tccc1++;\n        }\n        if(ccc1 >= min_gene)\n        \tc1.push_back(i);\n    }\n}\nvector <int> writeout(int left_row, int *row, int left_col, int *col, int num_gene, int num_patient, int wh){\n\tvector <int> result;\n\tresult.push_back(wh);\n\tresult.push_back(left_row);\n\tint pp=0;\n\tfor(int i=0; i< num_gene; i++){\n\t\tif(row[i]==0)\n\t\t\tcontinue;\n\t\tpp++;\n\t\tresult.push_back(i);\n\t}\n\tif(pp!=left_row){\n\t\tcout<<\"Error: row : \"<< pp <<\" \"<< left_row <<endl;\n\t}\n\tpp=0;\n\tresult.push_back(left_col);\n\tfor(int i=0; i< num_patient; i++){\n\t\tif(col[i]==0)\n\t\t\tcontinue;\n\t\tpp++;\n\t\tresult.push_back(i);\n\t}\n\tif(pp!=left_col){\n\t\tcout<<\"Error: col: \"<< pp <<\" \"<< left_col <<endl;\n\t}\n\treturn result;\n}\nint limitto(int *has_tag,float *has, int num_gene, int limited_num){\n\tfloat ct=pick(has,num_gene,limited_num);\n\tint x=0;\n\tfor(int j=0;j<num_gene;j++)\n    \tif(has[j] < ct )\n        \thas_tag[j]=0;\n       \telse\n        \tx++;\t\n    return x; \n}\n\nvoid removepatient(float **input,int *removal, int *has_tag, int wh, int num_patient, int num_gene, int min_patient,int has_used_num,float cutoff ){\n\tshort **record= new short*[has_used_num]; //a matrix to record the removal rank\n\tfor(int j=0;j < has_used_num;j++)\n    \trecord[j]=new short[num_patient];\n    int zz=0;\n    for(int j=0;j<num_gene;j++){ // to count or vote, use every gene as partner\n    \tif(has_tag[j]==0) // not similar\n        \tcontinue;\n\t\tint *use=new int[num_patient];\n\t\tinit(use, num_patient,1);\n\t\tint out= myremoval(wh,j,num_patient, input, min_patient,cutoff, use);\n\t\tif(out!=0){\n\t\t\tfor(int k=0;k<num_patient;k++)\n\t\t        record[zz][k]=use[k]; \n\t\t}\t\n\t\telse{\n\t\t    for(int k=0;k<num_patient;k++)\n\t\t        record[zz][k]=-1;\t \n\t\t}\n\t\tdelete use;\n        zz++;\n\t}\n    int step=30;\n    vote(record, removal,num_patient,has_used_num,step); // here we use a  widows of step to find which ones are very like to remove and rank them   \n    for(int j=0;j<has_used_num;j++)\n    \tdelete record[j];\n    delete record;         \n}\nvoid removepatient(float **input,int *removal, int *has_tag, int *col, int wh, int num_patient, int num_gene, int min_patient,int has_used_num,float cutoff ){\n\tshort **record= new short*[has_used_num]; //a matrix to record the removal rank\n\tfor(int j=0;j < has_used_num;j++)\n    \trecord[j]=new short[num_patient];\n    int zz=0;\n    for(int j=0;j<num_gene;j++){ // to count or vote, use every gene as partner\n    \tif(has_tag[j]==0) // not similar\n        \tcontinue;\n\t\tint *use=new int[num_patient];\n\t\tinit(use, num_patient,1);\n\t\tint out= myremoval(wh,j,num_patient, input, min_patient,cutoff, use);\n\t\tif(out!=0){\n\t\t\tfor(int k=0;k<num_patient;k++)\n\t\t        if(col[k]!=0)\n\t\t        \trecord[zz][k]=use[k];\n\t\t        else\n\t\t        \trecord[zz][k]=-1;\n\t\t}\t\n\t\telse{\n\t\t    for(int k=0;k<num_patient;k++)\n\t\t        record[zz][k]=-1;\t \n\t\t}\n\t\tdelete use;\n        zz++;\n\t}\n    int step=50;\n    vote(record, removal,num_patient,has_used_num,step); // here we use a  widows of step to find which ones are very like to remove and rank them   \n    for(int j=0;j<has_used_num;j++)\n    \tdelete record[j];\n    delete record;         \n}\n\nint refresh(float **input, int *removal, int *has, int *recordcol, int wh, int num_patient, int num_gene, int min_patient, int min_gene, float cutoff){\n\tint remove=0; // the number of removed patient\n    int max_have=0; // \n    int recordremove=-1; // the patinent number of removed record\n    int include_num=0; // the number of included genes\n    int col[num_patient];\n            init(col, num_patient, 1);\n            for(int k=0; k < num_patient; k++){ //vote to determined which will be remove\n            \tif( num_patient - remove < min_patient)\n                    return recordremove;\n                include_num=0;\n                if(removal[k] == -1)\n                    continue;\n                for(int g=0; g<num_gene; g++){ // count how many patients has good similar after remove one patients\n                    if(has[g]==0)\n                        continue;\n                    float r=newspearman(input, wh, g, col, num_patient, num_patient-remove);// the correlation after remove one patient\n                    if(r > cutoff)\n                        include_num++;\n                }\n                if(recordremove != -1 && remove > 0.4 * num_patient)\n                \treturn recordremove;\n                if(include_num > min_gene && include_num * ( num_patient - remove ) > max_have + 1){ // we will record the information with max coverage\n                   max_have=include_num * (num_patient-remove);\n                   recordremove = remove;\n                   for(int g=0; g < num_patient; g++){\n                       if(col[g] == 0){\n                            recordcol[g]=0;\n                        }\n                        else{\n                            recordcol[g]=1;\n                        }\n                   }\n                   if(remove > 0.4 * num_patient)\n                   \t\tbreak;\n                }\n                remove++;\n                col[removal[k]]=0;\n            }\n            return recordremove;\n}\nint compact(float **sim, int *has, int *recordcol, int wh, int recordremove, int num_gene, int num_patient, int min_gene, float overlap, float cutoff ){\n    int include_num=0;\n    map <int,int> tt; \n\tfor(int j=0;j<num_gene;j++){\n\t\tif(has[j]==0)\n\t\t\tcontinue;\n\t\ttt[j]=include_num;\n\t\tinclude_num++; // include itself, only for the un-used gene\n\t}\n\tshort **mx=new short*[include_num]; // a matrix indicate wether the genes have enough similarity\n\tfor(int j=0;j<include_num;j++){\n\t   \tmx[j]=new short[include_num];\n\t   \tfor(int k=0;k<include_num;k++)\n\t\t\tmx[j][k]=0;\t\n\t}        \n\tfor(int x=0; x < num_gene;x++){\n\t\tif(has[x]==0)\n\t\t\tcontinue;\n\t\tfor(int y=x;y<num_gene;y++){\n\t\t\tif(has[y]==0)\n\t\t    \tcontinue;\n\t\t\tif(sim[x][y] < cutoff)\n\t\t\t\tcontinue;\n\t\t\tmx[tt[x]][tt[y]]=1;\t\n\t\t\tmx[tt[y]][tt[x]]=1;\t\n\t\t}\n\t}\t\n\tint rm[include_num];\n\tinit(rm, include_num, 0);\n\tint new_include_num=connectivity(mx, rm, include_num, overlap, min_gene);\n\tfor(int j=0;j<include_num;j++)\n\t\tdelete mx[j]; \n\tdelete mx;\n\tfor(int i=0;i<num_gene;i++){\n\t\tif(has[i]==0)\n\t\t\tcontinue;\n\t\tif(rm[tt[i]]==1)\n\t\t\thas[i]=0;\n\t}\n\treturn new_include_num;\t           \n}\nint compact(float **input, float **sim, int *has, int *recordcol, int wh, int recordremove, int num_gene, int num_patient, int min_gene, float overlap, float cutoff ){ \n    map <int,int> tt; \n    int include_num=0;\n    for(int k=0;k<num_gene;k++){\n    \thas[k]=0;\n        float rr=newspearman(input, wh, k, recordcol,num_patient, num_patient-recordremove);\n        if(rr < cutoff)\n        \tcontinue;\n        tt[k]=include_num;\n        include_num++;\n        has[k]=1;\n    }\n\t\n\treturn include_num;\t           \n}\n\nvoid cormatrix(float **input, float *cor, int wh, int num_gene,int num_patient, int *col, int left_col){\n\tfor(int j=0; j < num_gene; j++)\n\t\tcor[j]=newspearman(input, wh, j, col, num_patient, left_col);\n}\n\nfloat average(vector <float> x){\n\tfloat sum=0;\n\tint n=x.size();\n\tfor(int i=0;i< n; i++)\n\t\tsum+=x[i];\n\treturn sum/n;\n}\n\n\n\n\n\n",
    "created" : 1504773593882.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1445199187",
    "id" : "3891C3CF",
    "lastKnownWriteTime" : 1504763554,
    "last_content_update" : 1504763554,
    "path" : "~/Desktop/bireg/src/util.h",
    "project_path" : "src/util.h",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "h"
}