#' Bi-clustering analysis to predicted the regulated patients and genes
#'
#' @param mx an expression matrix
#' @param regulators a vector for the index or gene name of regulators
#' @param min.ges the minimum number of regulated genes
#' @param min.pas the minimum number of regulated patients
#' @param cutoff the cutoff value of Spearman's correlation
#' @param cores the number of CPU cores
#' @param max.ges the maximum number of regulated genes
#'
#' @useDynLib bireg
#'
#' @author Guofeng Meng
#' @references
#'
#' @import parallel
#' @import Rcpp
#'
#'
#' @details Use a cpp program to do bi-clustering analysis to predict the genes and patients regulated by regulators
#'
#' @return A bca class object.
#'
#' @examples
#' res <- bca(expr, regulators, min.pas=50, min.ges=10, max.ges=60)
#'
#' @export


bca <- function( mx, regulators, min.pas=100, min.ges=50, cutoff=0.85, cores=1, max.ges=1000){
  print(class(mx))
  expr=as.matrix(mx)
  patients=colnames(mx)
  genes=row.names(mx)
  print(1)
  tfloc=regulators;
  if(!is.numeric(regulators))
    tfloc=which(genes %in% regulators)
  print(1)
  output=bcacpp(mx, tfloc, c(min.ges,max.ges, min.pas, 10, cutoff, cores))
  print(2)
  res=.transform(output)
  print(3)
  res[["para"]] <- list(patients=patients, genes=genes, tfloc=tfloc, min.pas=min.pas, min.ges=min.ges, cutoff=cutoff, cores=cores, max.ges=max.ges)
  attr(res, "class") <- "bca"
  return(res)
}

#' Extract regulated patients and genes
#'
#' @param bca.obj a ``bca'' object generated by "bca"
#' @param expr an expression matrix
#' @param mod the mode for extract the regulated patients and genes. It can be "max.genes" or "max.patients"
#'
#' @author Guofeng Meng
#' @references
#'
#' @import parallel
#' @import Rcpp
#'
#'
#' @details Use a cpp program to do bi-clustering analysis to predict the genes and patients regulated by regulators
#'
#' @return a list
#'
#' @examples
#' \dontrun{
#' output <- extract.modules(res, expr, "max.genes")
#' }
#' @export

extract.modules<-function(bca.obj, expr, mod="max.gene"){
  if (!is(bca.obj, "bca") )
    stop("Error: bca.obj: should be output of 'bca'");
  tfloc=bca.obj$para$tfloc;
  min.ges=bca.obj$para$min.ges;
  patients=bca.obj$para$patients;
  genes=bca.obj$para$genes;
  res=mclapply(tfloc, function(tf){
	  pas<-bca.obj[[as.character(tf)]][["pas"]]
	  nges<-bca.obj[[as.character(tf)]][["nges"]]
	  brk=which(nges > min.ges)[1]
	  if(is.na(brk))
	      return(NULL);
	  if(mod == "max.genes")
	    brk=which.max(nges)

	  select.pas=patients[-1*pas[1:brk]]
	  tp="DR";
	  if(length(select.pas) > 0.9* length(patients))
	     type="FR"
	  rr=abs(apply(expr[, select.pas], 1, function(x) cor(x, expr[tf, select.pas], method="spearman")))
	  select.ges=genes[rr > cutoff]
	  select.ges=select.ges[select.ges!=genes[tf]]
	  r1=sapply(select.ges, function(x) cor(expr[tf, select.pas], expr[x, select.pas], method="spearman"))
	  r2=sapply(select.ges, function(x) cor(expr[tf, !patients %in%select.pas], expr[x, !patients %in%select.pas], method="spearman"))
	  if(median(r2) > 0.7)
		  tp="FR";
	  if(median(r2) < 0.4)
		  tp="MR";
	  tmp=list(reg.genes=select.ges, reg.pas=select.pas, type=tp)
	  return(tmp)
  }, mc.cores=cores)
  names(res)<-genes[tfloc]
  return(res);
}


.transform<-function(x){
  res=list();
  i=1;
  tf="";
  pas=vector();
  nges=vector();
  rr=vector()
  while(1){
    tf=x[i];
    i=i+1;
    n.row=x[i];
    i=i+1;
    pas=x[i:(i+n.row-1)]  ;
    i= i + n.row;
    nges=x[i:(i+n.row-1)]  ;
    i= i + n.row;
    rr=x[i:(i+n.row-1)]  ;
    i= i + n.row;
    res[[as.character(tf)]]=list(pas=pas, nges=nges, r=rr)
    if(i > length(x))
      break();
  }
  if(i!=length(x)+1){
    print("warning: the number is unequal!");
  }
  return(res)
}

